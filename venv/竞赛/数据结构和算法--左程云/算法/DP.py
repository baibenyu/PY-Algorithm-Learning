# __project_ = 'pythonProject'
# __author_ = 'baibe'
# __time_ = '2022/6/11 14:37'

import time

if __name__ == '__main__':
    """
    动态规划:
    1.确定如何递归地进行尝试,能够遍历所有包含结果的情况--暴力搜索,时间复杂度->O(a**k),k是搜索时产生的a叉树的高度
    2.记忆,把一些重复的递归先记录下来,遇到时直接返回记忆值而不再重复计算,此时无所谓依赖关系--记忆化搜索,时间复杂度->O(k*N)
    3.尝试将记忆化搜索的依赖关系(状态转移方程)总结成表,并且确定遍历顺序--严格表结构的动态规划,同上
    4.优化空间复杂度--仅保留状态转移所必须的状态
    评价:1--单可变参数维度,即数(0维),数组(1维),矩阵(2维),越小越好
    2--可变参数个数,越少越好
    """
    start = time.perf_counter()
    """
    1.给定一个一维数组,起始位置s,终点位置e,限定步数k,求从s到e经过k步的有几种路径?
    解:分析结构,s有三种位置,左边界,中间,右边界,处于边界只能往相反方向前进,中间可以往两边前进,在尝试过程中仅有位置和剩余步数在改变,而终点就是位置为e,步数为0时
    2.给定一个硬币数组arr,长度为l,需要找回的金钱t,求最少需要多少枚硬币组合成t?
    注意:数组中的一个数代表一枚硬币
    解:硬币数在0-l之间,最多需要l枚,即选择全部硬币,或者说在l次选择中每次都选择使用了当前硬币,尝试过程中每枚硬币是否被使用及剩余金钱数在变化
    3.给定一个一维数组,两个人依次从两端取数,两人均为聪明人,问先手还是后手获胜?
    解:dp表示一方领先对手的分数,参考486题
    4.同问题1,不过此时位置数组为二维数组中的象棋盘,行走方式为马式,起始位置为(i,j),终点位置为(p,q),限定步数k,求起始到终点经过k步有几种路径?
    解:同解法1,但位置多了一维纵向,同理dp中也要多一维,其它相同,dp中的值仅依赖前一步的值,而不依赖当前步的值
    5.给定矩阵m*n,甲的位置(a,b),每次行走随机上下左右走一格,步数k,甲若超出矩阵范围则死亡,问甲活下来的概率是多少?
    注意:甲初始位置不一定在矩阵内,此时不可能存活
    解:不直接对概率求解,计算走完k步后仍留在矩阵内的存活路径数,用存活路径数/总路径数(4**k)即为存活概率
    6.给定一个硬币面值数组arr,长度为l,需要找回的金钱t,求有几种方法组合成t?
    注意:硬币可重复使用
    解:完全背包
    """
    end = time.perf_counter()
    print(end - start)
