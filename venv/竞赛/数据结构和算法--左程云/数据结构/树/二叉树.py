# __project_ = 'reptile'
# __author_ = 'baibe'
# __time_ = '2022/6/4 10:20'

import time

if __name__ == '__main__':
    start = time.clock()
    """
    1.遍历方式(前中后)的递归和迭代实现
    解:略
    2.找到一颗二叉树的最大宽度
    解:层序遍历时维护一个q的最大值即可
    3.判断一棵树是否是搜索二叉树
    解:1)--中序遍历是否得到升序数组
    2)--递归对所有子树都要求左数小于根结点,右数大于根结点
    4.判断一棵树是否是完全二叉树
    解:层序遍历,每个根结点都不能仅有右孩子而无左孩子,碰到第一个无右孩子的根结点往后所有结点都必须是叶子结点(无孩子)
    5.判断一棵树是否是满二叉树
    解:先求最大深度和结点个数,看是否满足2^深度-1 == 结点个数
    6.判断一棵树是否是平衡二叉树
    解:递归求最大深度过程中,更新左右子树高度差,看是否超过1
    7.找两个结点的最低公共祖先
    解:1)哈希表存储每个结点的父节点,从两个结点依次回溯往上,第一个相同即为答案
    2) 每个结点有四种状态--[1]当前结点为最低公共祖先,且不等于q或p结点,即q,p分别在左右子树中
    [2]当前结点为最低公共祖先,等于q或p结点,左右子树中含另一个结点
    [3]当前结点不为最低公共祖先,左右子树均不含q或p
    8.找某个结点的后继结点,前驱结点
    后继,前驱即中序遍历序列中的前后结点
    解:1)直接生成中序遍历
    2)[1]当前结点有右孩子,那么是右孩子的最左下结点,因为中序遍历是左根右,当前结点的后继即为右孩子的左中的第一个结点
    [2]当前结点没有右孩子,那么说明当前树的中序遍历已经结束,应该返回直至找到尚未完成的父节点,具体的此时的结点为父节点的左孩子,即为后继,此时为父树的中过程的第一个结点
    特殊的!!!整课树遍历结束时无后继,即最右结点无后继
    9.二叉树的序列化和反序列化
    解:任意遍历均可
    10.折纸问题,遍历凹凸出现顺序
    解:是一棵总根结点为凹,所有左孩子均为凹,右孩子均为凸,且每一次对折增加的孩子也遵循这个规律.是这棵树的中序遍历
    
    """
    end = time.clock()
    print(end - start)
