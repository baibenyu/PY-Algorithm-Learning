# __project_ = '算法学习'
# __author_ = 'baibe'
# __time_ = '2022/8/1 8:23'

import time
# 注意:不适用于负权环图
# 经典
# 步骤:1--建立动态规划dp[k][v],设起始点为u,此时DP表示恰好经过k条边后u到v的最短距离
#     2--dp[k][v] = min(dp[k][v],dp[k-1][v]+w(u,v)),此处的u是指能一步到达v的前驱结点
#     3--重复2直至所有点均被遍历一遍

# 优化--仅求最短路径而不关心经过的节点数(边数)时
# 步骤:1--建立距离数组d[],表示由起始点到其它点的最短距离
#     2--按相同顺序遍历所有的边,更新最短距离
#     3--重复2直至n-1遍,或者最短距离不更新时退出循环
#     4--若退出循环后,再进行步骤2的操作仍能更新最短距离,说明存在负权环,无解

# 再优化--仅求最短路径而不关心经过的节点数(边数)时
# SPFA算法--基于 队列 优化的 Bellman Ford算法
# 步骤:1--建立距离数组d[],表示由起始点到其它点的最短距离.建立队列q,保存被更新的结点
#     2--从队头弹出结点,并尝试更新相邻结点的最短路径,若成功且被更新的结点不在队列q中则添加,否则不添加
#     3--重复2直至队列为空
if __name__ == '__main__':
    start = time.perf_counter()

    end = time.perf_counter()
    print(end - start)
